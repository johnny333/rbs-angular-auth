{"version":3,"sources":["main.litcoffee","rbs-angular-auth.js","service/TokenManager.litcoffee","service/RuleParser.litcoffee","service/JWT.litcoffee","interceptor/TokenInterceptor.litcoffee","interceptor/SecurityErrorInterceptor.litcoffee","controller/SecurityCtrl.litcoffee","config/router.litcoffee","config/module.litcoffee"],"names":["angular","module","call","this","factory","$log","$localStorage","$rootScope","Configuration","JWT_CLEAR_EVENT","JWT_EXTRACTOR","JWT_INJECTOR","JWT_STORAGE_KEY","JWT_STORE_EVENT","TokenManager","prototype","storeRaw","token","getRaw","debug","$broadcast","clear","inject","request","rawToken","extract","response","And","Operator","Or","RuleParser","alt","conjunction","conjunctionNext","disjunction","disjunctionNext","lazy","lexeme","lparen","member","opAnd","opOr","optWhitespace","regex","rparen","rule","seq","string","subrule","slice","extend","child","parent","ctor","constructor","key","hasProp","__super__","hasOwnProperty","permissions","arguments","length","evalPermission","principal","permissionCheck","permission","isString","isFunction","superClass","apply","_","every","toJSON","and","some","or","Parsimmon","p","skip","many","map","arg","first","more","func","args","result","Object","concat","then","parse","memoize","r","trim","ErrorFactory","JWT","format","header","payload","isObject","KJUR","jws","JWS","sign","toJson","verifyKey","ok","ref","signature","split","isNumber","verify","ERROR_STATUS","NOT_AUTHORIZED","ERROR_CODE","INVALID_TOKEN_SIGNATURE","fromJson","readSafeJSONString","b64utos","bind","fn","me","$q","cfg","TokenInterceptor","isEnabled","config","HTTP_URL_FILTER","S","url","startsWith","isRegExp","test","fromParam","params","JWT_REQUEST_PARAM","indexOf","item","i","l","SecurityErrorInterceptor","responseError","rejection","error","errorMessage","ref1","status","HTTP_AUTHORIZATION_ERROR_STATUS","data","message","create","NO_HTTP_AUTHORIZATION","HTTP_AUTHORIZATION_ERROR_EVENT","reject","service","SecurityCtrl","$on","_this","initialize","clearCaches","base","base1","base2","isAuthorized","cache","$readPrincipal","$readPayload","onFailure","onSuccess","getPrincipal","$fetchPrincipal","$$readPayload","error1","$$readPrincipal","when","isAuthenticated","$$isAuthorized","parsed","JWT_PERMISSION_CHECK","value","BAD_REQUEST","INVALID_AUTHORIZATION_RULE","$isAuthorized","logout","$httpProvider","ConfigurationProvider","put","NO_ROUTE_AUTHORIZATION","run","SecurityCtrlInstance","event","toState","toParams","fromState","fromParams","authorization","DATA_AUTHORIZATION_KEY","error2","name","ROUTER_AUTHORIZATION_ERROR_EVENT","preventDefault","AUTHORIZATION_HEADER","BEARER_REGEX","BEARER_TEMPLATE","TemplateTokenExtractor","TemplateTokenInjector","template","headers","s","constant","headerName","match","whole","exec","isArray","FORBIDDEN","interceptors","push","SECURITY_CONTROLLER_AS"],"mappings":"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","file":"rbs-angular-auth.min.js","sourcesContent":["Główny moduł:\n\n    angular.module 'rbs-angular-auth', [\n      'ngStorage'\n      'rbs-angular-core'\n    ]\n\nModuł integracji z `ui-router`:\n\n    angular.module 'rbs-angular-auth-ui-router', [\n      'ui.router'\n      'rbs-angular-auth'\n    ]\n\nModuł zawierający przykłady wykorzystywane w dokumentacji:\n\n    angular.module 'rbs-angular-auth-samples', [\n      'rbs-angular-auth-samples'\n    ]\n","(function() {\n  angular.module('rbs-angular-auth', ['ngStorage', 'rbs-angular-core']);\n\n  angular.module('rbs-angular-auth-ui-router', ['ui.router', 'rbs-angular-auth']);\n\n  angular.module('rbs-angular-auth-samples', ['rbs-angular-auth-samples']);\n\n}).call(this);\n\n(function() {\n  (angular.module('rbs-angular-auth')).factory('TokenManager', [\n    '$log', '$localStorage', '$rootScope', 'Configuration', function($log, $localStorage, $rootScope, Configuration) {\n      var JWT_CLEAR_EVENT, JWT_EXTRACTOR, JWT_INJECTOR, JWT_STORAGE_KEY, JWT_STORE_EVENT, TokenManager;\n      JWT_STORAGE_KEY = Configuration.JWT_STORAGE_KEY;\n      JWT_STORE_EVENT = Configuration.JWT_STORE_EVENT;\n      JWT_CLEAR_EVENT = Configuration.JWT_CLEAR_EVENT;\n      JWT_INJECTOR = Configuration.JWT_INJECTOR;\n      JWT_EXTRACTOR = Configuration.JWT_EXTRACTOR;\n      TokenManager = (function() {\n        function TokenManager() {}\n\n        TokenManager.prototype.storeRaw = function(token) {\n          if (this.getRaw() !== token) {\n            $log.debug('Store JWT token: ', token);\n            $localStorage[JWT_STORAGE_KEY] = token;\n            return $rootScope.$broadcast(JWT_STORE_EVENT, this, token);\n          }\n        };\n\n        TokenManager.prototype.getRaw = function() {\n          return $localStorage[JWT_STORAGE_KEY];\n        };\n\n        TokenManager.prototype.clear = function() {\n          var token;\n          token = this.getRaw();\n          $log.debug('Cleared JWT token: ', token);\n          delete $localStorage[JWT_STORAGE_KEY];\n          return $rootScope.$broadcast(JWT_CLEAR_EVENT, this, token);\n        };\n\n        TokenManager.prototype.inject = function(request, rawToken) {\n          JWT_INJECTOR(request, rawToken);\n          return request;\n        };\n\n        TokenManager.prototype.extract = function(response) {\n          return JWT_EXTRACTOR(response);\n        };\n\n        return TokenManager;\n\n      })();\n      return new TokenManager();\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  var And, Operator, Or, RuleParser, alt, conjunction, conjunctionNext, disjunction, disjunctionNext, lazy, lexeme, lparen, member, opAnd, opOr, optWhitespace, regex, rparen, rule, seq, string, subrule,\n    slice = [].slice,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Operator = (function() {\n    function Operator() {\n      var permissions;\n      permissions = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      this.permissions = permissions;\n    }\n\n    Operator.evalPermission = function(principal, permissionCheck) {\n      return function(permission) {\n        if (angular.isString(permission)) {\n          return permissionCheck(principal, permission);\n        } else if (angular.isFunction(permission != null ? permission[\"eval\"] : void 0)) {\n          return permission[\"eval\"](principal, permissionCheck);\n        }\n      };\n    };\n\n    return Operator;\n\n  })();\n\n  And = (function(superClass) {\n    extend(And, superClass);\n\n    function And() {\n      return And.__super__.constructor.apply(this, arguments);\n    }\n\n    And.prototype[\"eval\"] = function(principal, permissionCheck) {\n      return _.every(this.permissions, Operator.evalPermission(principal, permissionCheck));\n    };\n\n    And.prototype.toJSON = function() {\n      return {\n        \"and\": this.permissions\n      };\n    };\n\n    return And;\n\n  })(Operator);\n\n  Or = (function(superClass) {\n    extend(Or, superClass);\n\n    function Or() {\n      return Or.__super__.constructor.apply(this, arguments);\n    }\n\n    Or.prototype[\"eval\"] = function(principal, permissionCheck) {\n      return _.some(this.permissions, Operator.evalPermission(principal, permissionCheck));\n    };\n\n    Or.prototype.toJSON = function() {\n      return {\n        \"or\": this.permissions\n      };\n    };\n\n    return Or;\n\n  })(Operator);\n\n  alt = Parsimmon.alt;\n\n  seq = Parsimmon.seq;\n\n  lazy = Parsimmon.lazy;\n\n  regex = Parsimmon.regex;\n\n  string = Parsimmon.string;\n\n  optWhitespace = Parsimmon.optWhitespace;\n\n  lexeme = function(p) {\n    return p.skip(optWhitespace);\n  };\n\n  lparen = lexeme(string('('));\n\n  rparen = lexeme(string(')'));\n\n  opOr = lexeme(string('|'));\n\n  opAnd = lexeme(string('&'));\n\n  member = lexeme(regex(/[0-9a-z_\\-\\.]+/i));\n\n  rule = lazy('rule', function() {\n    return seq(conjunction, disjunctionNext.many()).map(function(arg) {\n      var first, more;\n      first = arg[0], more = arg[1];\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Or, [first].concat(slice.call(more)), function(){});\n    });\n  });\n\n  subrule = lparen.then(rule).skip(rparen).or(member);\n\n  conjunctionNext = opAnd.then(subrule);\n\n  conjunction = seq(subrule, conjunctionNext.many()).map(function(arg) {\n    var first, more;\n    first = arg[0], more = arg[1];\n    if (more.length) {\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(And, [first].concat(slice.call(more)), function(){});\n    } else {\n      return first;\n    }\n  });\n\n  disjunctionNext = opOr.then(conjunction);\n\n  disjunction = seq(subrule, disjunctionNext.many()).map(function(arg) {\n    var first, more;\n    first = arg[0], more = arg[1];\n    if (more.length) {\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Or, [first].concat(slice.call(more)), function(){});\n    } else {\n      return first;\n    }\n  });\n\n  RuleParser = (function() {\n    function RuleParser() {}\n\n    RuleParser.parse = _.memoize(function(r) {\n      return rule.parse((r != null ? r.trim() : void 0) || '');\n    });\n\n    return RuleParser;\n\n  })();\n\n  (angular.module('rbs-angular-auth')).factory('RuleParser', [\n    '$log', function($log) {\n      return RuleParser;\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  (angular.module('rbs-angular-auth')).factory('JWT', [\n    '$log', 'ErrorFactory', 'Configuration', function($log, ErrorFactory, Configuration) {\n      var JWT;\n      JWT = (function() {\n        function JWT() {}\n\n        JWT.format = function(header, payload, key) {\n          if (!((angular.isObject(header)) && (angular.isObject(payload)) && (key != null))) {\n            return void 0;\n          }\n          return KJUR.jws.JWS.sign(null, angular.toJson(header), angular.toJson(payload), key);\n        };\n\n        JWT.parse = function(token, verifyKey) {\n          var header, ok, payload, ref, signature;\n          if (token == null) {\n            return void 0;\n          }\n          ref = token.split('.'), header = ref[0], payload = ref[1], signature = ref[2];\n          ok = verifyKey ? (angular.isNumber(verifyKey) ? verifyKey = '' + verifyKey : void 0, KJUR.jws.JWS.verify(token, verifyKey)) : true;\n          if (!ok) {\n            ErrorFactory[\"throw\"](Configuration.ERROR_STATUS.NOT_AUTHORIZED, Configuration.ERROR_CODE.INVALID_TOKEN_SIGNATURE, \"Invalid JWT token signature\");\n          }\n          return {\n            header: angular.fromJson(KJUR.jws.JWS.readSafeJSONString(b64utos(header))),\n            payload: angular.fromJson(KJUR.jws.JWS.readSafeJSONString(b64utos(payload)))\n          };\n        };\n\n        return JWT;\n\n      })();\n      return JWT;\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  (angular.module('rbs-angular-auth')).factory('TokenInterceptor', [\n    '$log', '$q', 'TokenManager', 'Configuration', function($log, $q, TokenManager, cfg) {\n      var TokenInterceptor;\n      TokenInterceptor = (function() {\n        function TokenInterceptor() {\n          this.request = bind(this.request, this);\n          this.response = bind(this.response, this);\n        }\n\n        TokenInterceptor.prototype.isEnabled = function(config) {\n          if (angular.isString(cfg.HTTP_URL_FILTER)) {\n            return S(config.url).startsWith(cfg.HTTP_URL_FILTER);\n          } else if (angular.isFunction(cfg.HTTP_URL_FILTER)) {\n            return cfg.HTTP_URL_FILTER(config.url);\n          } else if (_.isRegExp(cfg.HTTP_URL_FILTER)) {\n            return cfg.HTTP_URL_FILTER.test(config.url);\n          } else {\n            return true;\n          }\n        };\n\n        TokenInterceptor.prototype.response = function(response) {\n          var token;\n          if (this.isEnabled(response.config)) {\n            token = TokenManager.extract(response);\n            if (token != null) {\n              TokenManager.storeRaw(token);\n            }\n          }\n          return response;\n        };\n\n        TokenInterceptor.prototype.request = function(config) {\n          var fromParam, ref, token;\n          if (this.isEnabled(config)) {\n            fromParam = (ref = config.params) != null ? ref[cfg.JWT_REQUEST_PARAM] : void 0;\n            token = fromParam != null ? (delete config.params[cfg.JWT_REQUEST_PARAM], fromParam) : TokenManager.getRaw();\n            if (token != null) {\n              return TokenManager.inject(config, token) || config;\n            } else {\n              return config;\n            }\n          } else {\n            return config;\n          }\n        };\n\n        return TokenInterceptor;\n\n      })();\n      return new TokenInterceptor();\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  (angular.module('rbs-angular-auth')).factory('SecurityErrorInterceptor', [\n    '$log', '$rootScope', '$q', 'Configuration', 'ErrorFactory', function($log, $rootScope, $q, cfg, ErrorFactory) {\n      var SecurityErrorInterceptor;\n      SecurityErrorInterceptor = (function() {\n        function SecurityErrorInterceptor() {}\n\n        SecurityErrorInterceptor.prototype.responseError = function(rejection) {\n          var error, errorMessage, ref, ref1;\n          error = (ref = rejection.status, indexOf.call(cfg.HTTP_AUTHORIZATION_ERROR_STATUS || [], ref) >= 0) ? (errorMessage = angular.isString(rejection.data) ? rejection.data : angular.isString((ref1 = rejection.data) != null ? ref1.message : void 0) ? rejection.data.message : 'Server returned authorization error', error = ErrorFactory.create(rejection.status, cfg.ERROR_CODE.NO_HTTP_AUTHORIZATION, errorMessage, rejection), $rootScope.$broadcast(cfg.HTTP_AUTHORIZATION_ERROR_EVENT, error), error) : rejection;\n          return $q.reject(error);\n        };\n\n        return SecurityErrorInterceptor;\n\n      })();\n      return new SecurityErrorInterceptor();\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  (angular.module('rbs-angular-auth')).service('SecurityCtrl', [\n    '$log', '$q', '$rootScope', 'Configuration', 'ErrorFactory', 'JWT', 'RuleParser', 'TokenManager', function($log, $q, $rootScope, cfg, ErrorFactory, JWT, RuleParser, TokenManager) {\n      var SecurityCtrl;\n      SecurityCtrl = (function() {\n        function SecurityCtrl() {\n          this.principal = void 0;\n          this.payload = void 0;\n          $rootScope.$on(cfg.JWT_STORE_EVENT, (function(_this) {\n            return function() {\n              return _this.initialize();\n            };\n          })(this));\n          $rootScope.$on(cfg.JWT_CLEAR_EVENT, (function(_this) {\n            return function() {\n              return _this.initialize();\n            };\n          })(this));\n          this.initialize();\n        }\n\n        SecurityCtrl.prototype.clearCaches = function() {\n          var base, base1, base2;\n          if (typeof (base = this.isAuthorized.cache).clear === \"function\") {\n            base.clear();\n          }\n          if (typeof (base1 = this.$readPrincipal.cache).clear === \"function\") {\n            base1.clear();\n          }\n          return typeof (base2 = this.$readPayload.cache).clear === \"function\" ? base2.clear() : void 0;\n        };\n\n        SecurityCtrl.prototype.initialize = function() {\n          var onFailure, onSuccess;\n          this.clearCaches();\n          this.payload = this.$readPayload();\n          onSuccess = (function(_this) {\n            return function(principal) {\n              _this.clearCaches();\n              return _this.principal = principal;\n            };\n          })(this);\n          onFailure = (function(_this) {\n            return function() {\n              _this.clearCaches();\n              return _this.principal = void 0;\n            };\n          })(this);\n          return this.getPrincipal().then(onSuccess, onFailure);\n        };\n\n        SecurityCtrl.prototype.$fetchPrincipal = function(payload) {\n          return payload;\n        };\n\n        SecurityCtrl.prototype.$$readPayload = function() {\n          var error, header, payload, rawToken, token;\n          rawToken = TokenManager.getRaw();\n          token = (function() {\n            var error1;\n            try {\n              return JWT.parse(rawToken);\n            } catch (error1) {\n              error = error1;\n              $log.error(\"Can't parse token:\", rawToken, error);\n              return TokenManager.clear();\n            }\n          })();\n          if (token != null) {\n            header = token.header, payload = token.payload;\n            return payload;\n          }\n        };\n\n        SecurityCtrl.prototype.$readPayload = _.memoize(SecurityCtrl.prototype.$$readPayload, function() {\n          return 'SecurityCtrl-readPayload';\n        });\n\n        SecurityCtrl.prototype.$$readPrincipal = function() {\n          var payload;\n          payload = this.$readPayload();\n          if (payload != null) {\n            return $q.when(this.$fetchPrincipal(payload));\n          } else {\n            return $q.reject();\n          }\n        };\n\n        SecurityCtrl.prototype.$readPrincipal = _.memoize(SecurityCtrl.prototype.$$readPrincipal, function() {\n          return 'SecurityCtrl-readPrincipal';\n        });\n\n        SecurityCtrl.prototype.getPrincipal = function() {\n          return this.$readPrincipal();\n        };\n\n        SecurityCtrl.prototype.isAuthenticated = function() {\n          return this.payload != null;\n        };\n\n        SecurityCtrl.prototype.$$isAuthorized = function(rule, payload) {\n          var parsed;\n          if (rule == null) {\n            return payload != null;\n          } else if ((payload != null) && angular.isFunction(cfg.JWT_PERMISSION_CHECK)) {\n            parsed = RuleParser.parse(rule);\n            if (parsed.status) {\n              return parsed.value[\"eval\"](payload, cfg.JWT_PERMISSION_CHECK) === true;\n            } else {\n              return ErrorFactory[\"throw\"](cfg.ERROR_STATUS.BAD_REQUEST, cfg.ERROR_CODE.INVALID_AUTHORIZATION_RULE, \"Can't parse authorization rule: \\\"\" + rule + \"\\\"\");\n            }\n          } else {\n            return false;\n          }\n        };\n\n        SecurityCtrl.prototype.$isAuthorized = function(rule) {\n          return this.$$isAuthorized(rule, this.payload);\n        };\n\n        SecurityCtrl.prototype.isAuthorized = _.memoize(SecurityCtrl.prototype.$isAuthorized, function(rule) {\n          return rule || 'SecurityCtrl-isAuthorized';\n        });\n\n        SecurityCtrl.prototype.logout = function() {\n          return TokenManager.clear();\n        };\n\n        return SecurityCtrl;\n\n      })();\n      return SecurityCtrl;\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  (angular.module('rbs-angular-auth-ui-router')).config([\n    '$httpProvider', 'ConfigurationProvider', function($httpProvider, ConfigurationProvider) {\n      ConfigurationProvider.put('DATA_AUTHORIZATION_KEY', 'authorize');\n      ConfigurationProvider.put('ROUTER_AUTHORIZATION_ERROR_EVENT', 'rbs-angular-auth-ui-router-error');\n      return ConfigurationProvider.put('ERROR_CODE', {\n        NO_ROUTE_AUTHORIZATION: '0a38f636-c123-4cd5-9249-ad9b6c6724a9'\n      });\n    }\n  ]);\n\n  (angular.module('rbs-angular-auth-ui-router')).run([\n    '$log', '$rootScope', 'Configuration', 'ErrorFactory', 'SecurityCtrlInstance', function($log, $rootScope, cfg, ErrorFactory, SecurityCtrlInstance) {\n      return $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {\n        var authorization, error, ref;\n        authorization = (ref = toState.data) != null ? ref[cfg.DATA_AUTHORIZATION_KEY] : void 0;\n        if (authorization) {\n          error = (function() {\n            var error1, error2;\n            if (authorization === true) {\n              try {\n                if (!SecurityCtrlInstance.isAuthenticated()) {\n                  return ErrorFactory.create(cfg.ERROR_STATUS.NOT_AUTHORIZED, cfg.ERROR_CODE.NO_ROUTE_AUTHORIZATION, (\"State \\\"\" + toState.name + \"\\\" is guarded with authorization rule: \\\"\" + authorization + \"\\\", which is not\") + \" matched\");\n                }\n              } catch (error1) {\n                error = error1;\n                return error;\n              }\n            } else if (angular.isString(authorization)) {\n              try {\n                if (!SecurityCtrlInstance.isAuthorized(authorization)) {\n                  return ErrorFactory.create(cfg.ERROR_STATUS.NOT_AUTHORIZED, cfg.ERROR_CODE.NO_ROUTE_AUTHORIZATION, (\"State \\\"\" + toState.name + \"\\\" is guarded with authorization rule: \\\"\" + authorization + \"\\\", which is not\") + \" matched\");\n                }\n              } catch (error2) {\n                error = error2;\n                return error;\n              }\n            }\n          })();\n          if (error != null) {\n            $rootScope.$broadcast(cfg.ROUTER_AUTHORIZATION_ERROR_EVENT, toState, toParams, fromState, fromParams, error);\n            return event.preventDefault();\n          }\n        }\n      });\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  var AUTHORIZATION_HEADER, BEARER_REGEX, BEARER_TEMPLATE, TemplateTokenExtractor, TemplateTokenInjector;\n\n  AUTHORIZATION_HEADER = 'Authorization';\n\n  BEARER_REGEX = /Bearer ([0-9A-Za-z\\.\\-_]+)/;\n\n  BEARER_TEMPLATE = \"Bearer {{token}}\";\n\n  TemplateTokenInjector = function(header, template) {\n    if (header == null) {\n      header = AUTHORIZATION_HEADER;\n    }\n    if (template == null) {\n      template = BEARER_TEMPLATE;\n    }\n    return function(request, rawToken) {\n      return request.headers[header] = angular.isString(template) ? S(template).template({\n        token: rawToken,\n        rawToken: rawToken\n      }).s : angular.isFunction(template) ? template(rawToken) : rawToken;\n    };\n  };\n\n  (angular.module('rbs-angular-auth')).constant('TemplateTokenInjector', TemplateTokenInjector);\n\n  TemplateTokenExtractor = function(headerName, template) {\n    if (headerName == null) {\n      headerName = AUTHORIZATION_HEADER;\n    }\n    if (template == null) {\n      template = BEARER_REGEX;\n    }\n    return function(response) {\n      var header, match, rawToken, whole;\n      header = response.headers(headerName);\n      if (header != null) {\n        if (_.isRegExp(template)) {\n          match = template.exec(header);\n          if (angular.isArray(match)) {\n            whole = match[0], rawToken = match[1];\n            return rawToken;\n          }\n        } else if (angular.isFunction(template)) {\n          return template(header);\n        } else {\n          return header;\n        }\n      }\n    };\n  };\n\n  (angular.module('rbs-angular-auth')).constant('TemplateTokenExtractor', TemplateTokenExtractor);\n\n  (angular.module('rbs-angular-auth')).config([\n    '$httpProvider', 'ConfigurationProvider', 'TemplateTokenExtractor', 'TemplateTokenInjector', function($httpProvider, ConfigurationProvider, TemplateTokenExtractor, TemplateTokenInjector) {\n      ConfigurationProvider.put('JWT_STORAGE_KEY', 'JWT');\n      ConfigurationProvider.put('SECURITY_CONTROLLER_AS', 'security');\n      ConfigurationProvider.put('JWT_STORE_EVENT', 'rbs-angular-auth-JWT-store');\n      ConfigurationProvider.put('JWT_CLEAR_EVENT', 'rbs-angular-auth-JWT-clear');\n      ConfigurationProvider.put('HTTP_URL_FILTER', function() {\n        return true;\n      });\n      ConfigurationProvider.put('HTTP_AUTHORIZATION_ERROR_STATUS', [401, 403]);\n      ConfigurationProvider.put('HTTP_AUTHORIZATION_ERROR_EVENT', 'rbs-angular-auth-http-error');\n      ConfigurationProvider.put('JWT_PERMISSION_CHECK', _.constant(false));\n      ConfigurationProvider.put('JWT_INJECTOR', TemplateTokenInjector());\n      ConfigurationProvider.put('JWT_EXTRACTOR', TemplateTokenExtractor());\n      ConfigurationProvider.put('ERROR_STATUS', {\n        BAD_REQUEST: 400,\n        NOT_AUTHORIZED: 401,\n        FORBIDDEN: 403\n      });\n      ConfigurationProvider.put('ERROR_CODE', {\n        INVALID_TOKEN_SIGNATURE: '3b2600fb-8d22-497c-a49b-3dab0b501f04',\n        INVALID_AUTHORIZATION_RULE: '6af67e3a-23bc-4e5d-a46b-839e1ad7425f',\n        NO_HTTP_AUTHORIZATION: 'c472ad9e-d303-4880-aa92-f788c2b0030e'\n      });\n      ConfigurationProvider.put('JWT_REQUEST_PARAM', 'access_token');\n      $httpProvider.interceptors.push('SecurityErrorInterceptor');\n      return $httpProvider.interceptors.push('TokenInterceptor');\n    }\n  ]);\n\n  (angular.module('rbs-angular-auth')).factory('SecurityCtrlInstance', [\n    '$log', 'SecurityCtrl', function($log, SecurityCtrl) {\n      return new SecurityCtrl();\n    }\n  ]);\n\n  (angular.module('rbs-angular-auth')).run([\n    '$log', '$rootScope', 'Configuration', 'SecurityCtrlInstance', function($log, $rootScope, cfg, SecurityCtrlInstance) {\n      return $rootScope[cfg.SECURITY_CONTROLLER_AS] = SecurityCtrlInstance;\n    }\n  ]);\n\n}).call(this);\n\n//# sourceMappingURL=rbs-angular-auth.js.map\n","# `TokenManager`\n\nZarządzanie tokenem JWT.\n\n    (angular.module 'rbs-angular-auth').factory 'TokenManager', [\n      '$log'\n      '$localStorage'\n      '$rootScope'\n      'Configuration'\n      ($log, $localStorage, $rootScope, Configuration) ->\n\n        JWT_STORAGE_KEY = Configuration.JWT_STORAGE_KEY\n        JWT_STORE_EVENT = Configuration.JWT_STORE_EVENT\n        JWT_CLEAR_EVENT = Configuration.JWT_CLEAR_EVENT\n        JWT_INJECTOR    = Configuration.JWT_INJECTOR\n        JWT_EXTRACTOR   = Configuration.JWT_EXTRACTOR\n\n        class TokenManager\n\nToken zapisywany jest do `localStorage`.\n\n          storeRaw: (token) ->\n            if @getRaw() isnt token\n              $log.debug 'Store JWT token: ', token\n              $localStorage[JWT_STORAGE_KEY] = token\n              $rootScope.$broadcast JWT_STORE_EVENT, this, token\n\nToken pobierany jest z `localStorage`.\n\n          getRaw: () ->\n            $localStorage[JWT_STORAGE_KEY]\n\nToken jest usuwany `localStorage`.\n\n          clear: () ->\n            token = @getRaw()\n            $log.debug 'Cleared JWT token: ', token\n            delete $localStorage[JWT_STORAGE_KEY]\n            $rootScope.$broadcast JWT_CLEAR_EVENT, this, token\n\nToken przekazujemy w nagłówku `Authorization` żądania, z prefiksem \"Bearer\".\n\n          inject: (request, rawToken) ->\n            JWT_INJECTOR request, rawToken\n            request\n\nToken wyciągamy z nagłówka `Authorization` odpowiedzi, z prefiksem \"Bearer\".\n\n          extract: (response) ->\n            JWT_EXTRACTOR response\n\n        new TokenManager()\n    ]\n","# `RuleParser`\n\nParser reguł autoryzacyjnych. Reguły mogą zawierać nazwy ról oraz znaki `(`, `)`, `|`, `&`.\n\n    class Operator\n\n      constructor: (@permissions...) ->\n\n      @evalPermission: (principal, permissionCheck) ->\n        (permission) ->\n          if angular.isString permission\n            permissionCheck(principal, permission)\n          else if angular.isFunction permission?.eval\n            permission.eval principal, permissionCheck\n\n    class And extends Operator\n\n      eval: (principal, permissionCheck) ->\n        _.every @permissions, Operator.evalPermission(principal, permissionCheck)\n\n      toJSON: () ->\n        \"and\": @permissions\n\n    class Or extends Operator\n\n      eval: (principal, permissionCheck) ->\n        _.some @permissions, Operator.evalPermission(principal, permissionCheck)\n\n      toJSON: () ->\n        \"or\": @permissions\n\n    alt = Parsimmon.alt\n    seq = Parsimmon.seq\n    lazy = Parsimmon.lazy\n    regex = Parsimmon.regex\n    string = Parsimmon.string\n    optWhitespace = Parsimmon.optWhitespace\n\n    lexeme = (p) -> p.skip optWhitespace\n\n    lparen = lexeme string '('\n    rparen = lexeme string ')'\n    opOr = lexeme string '|'\n    opAnd = lexeme string '&'\n    member = lexeme regex /[0-9a-z_\\-\\.]+/i\n\n    rule = lazy 'rule', ->\n      seq(conjunction, disjunctionNext.many()).map ([first, more]) -> new Or(first, more...)\n    subrule = lparen.then(rule).skip(rparen).or(member)\n    conjunctionNext = opAnd.then(subrule)\n    conjunction = seq(subrule, conjunctionNext.many()).map ([first, more]) ->\n      if more.length\n        new And(first, more...)\n      else\n        first\n    disjunctionNext = opOr.then(conjunction) # plus\n    disjunction = seq(subrule, disjunctionNext.many()).map ([first, more]) ->\n      if more.length\n        new Or(first, more...)\n      else\n        first\n\n    class RuleParser\n\n      @parse: _.memoize (r) -> rule.parse r?.trim() or ''\n\n    (angular.module 'rbs-angular-auth').factory 'RuleParser', [\n      '$log'\n      ($log) -> RuleParser\n    ]\n","# `JWT`\n\nFormater i parser tokenu JWT.\n\n    (angular.module 'rbs-angular-auth').factory 'JWT', [\n      '$log'\n      'ErrorFactory'\n      'Configuration'\n      ($log, ErrorFactory, Configuration) ->\n\n        class JWT\n\nFormatowanie tokenu składającego się z nagłówka `header` i ciała `payload` z opcjonalnym podpisem kluczem `key`.\n\n          @format: (header, payload, key) ->\n            return undefined unless (angular.isObject header) and (angular.isObject payload) and key?\n            KJUR.jws.JWS.sign null, angular.toJson(header), angular.toJson(payload), key\n\nParsowanie tokenu z opcjonalną weryfikacją podpisu kluczem `verifyKey`.\n\n          @parse: (token, verifyKey) ->\n            return undefined unless token?\n            [header, payload, signature] = token.split '.'\n            ok = if verifyKey\n              if angular.isNumber verifyKey\n                verifyKey = '' + verifyKey\n              KJUR.jws.JWS.verify(token, verifyKey)\n            else true\n            unless ok\n              ErrorFactory.throw Configuration.ERROR_STATUS.NOT_AUTHORIZED,\n               Configuration.ERROR_CODE.INVALID_TOKEN_SIGNATURE,\n               \"Invalid JWT token signature\"\n            {\n              header: angular.fromJson KJUR.jws.JWS.readSafeJSONString(b64utos(header))\n              payload: angular.fromJson KJUR.jws.JWS.readSafeJSONString(b64utos(payload))\n            }\n\n        JWT\n    ]\n","# `TokenInterceptor`\n\nInterceptor `$http`, który:\n\n    (angular.module 'rbs-angular-auth').factory 'TokenInterceptor', [\n      '$log'\n      '$q'\n      'TokenManager'\n      'Configuration'\n      ($log, $q, TokenManager, cfg) ->\n\n        class TokenInterceptor\n\n          isEnabled: (config) ->\n            if angular.isString cfg.HTTP_URL_FILTER\n              S(config.url).startsWith(cfg.HTTP_URL_FILTER)\n            else if angular.isFunction cfg.HTTP_URL_FILTER\n              cfg.HTTP_URL_FILTER config.url\n            else if _.isRegExp cfg.HTTP_URL_FILTER\n              cfg.HTTP_URL_FILTER.test config.url\n            else true\n\n* odczytuje token `JWT` z żądania (`TokenManager`.`extract`) i zapisuje go  (`TokenManager`.`storeRaw`):\n\n          response: (response) =>\n            if @isEnabled response.config\n              token = TokenManager.extract(response)\n              if token?\n                TokenManager.storeRaw(token)\n            response\n\n* odczytuje zapisany token `JWT` (`TokenManager`.`getRaw`) i przekazuje go w każdym żądaniu\n  (`TokenManager`.`inject`):\n\n          request: (config) =>\n            if @isEnabled config\n              fromParam = config.params?[cfg.JWT_REQUEST_PARAM]\n              token = if fromParam?\n                delete config.params[cfg.JWT_REQUEST_PARAM]\n                fromParam\n              else\n                TokenManager.getRaw()\n              if token?\n                TokenManager.inject(config, token) or config\n              else\n                config\n            else\n              config\n\n        new TokenInterceptor()\n    ]\n","# `SecurityErrorInterceptor`\n\nInterceptor `$http` przechwytujący błędy HTTP związane z autoryzacją i publikujące je w formie zdarzeń w `$rootScope`.\n\n    (angular.module 'rbs-angular-auth').factory 'SecurityErrorInterceptor', [\n      '$log'\n      '$rootScope'\n      '$q'\n      'Configuration'\n      'ErrorFactory'\n      ($log, $rootScope, $q, cfg, ErrorFactory) ->\n\n        class SecurityErrorInterceptor\n\n          responseError: (rejection) ->\n\nKody błędów, które mają być obsługiwane (domyślnie `401`, `403`) można ustawić w `ConfigurationProvider`\npod kluczem `HTTP_AUTHORIZATION_ERROR_STATUS`.\n\n            error = if rejection.status in (cfg.HTTP_AUTHORIZATION_ERROR_STATUS or [])\n\nW przypadku błędu zawiera wyjątek `ApplicationError` z ustawionymi polami:\n* `status` - status HTTP błędu\n* `code` - wartość ustawiona w `ConfigurationProvider` - `ERROR_CODE`.`NO_HTTP_AUTHORIZATION`\n* `message` - oryginalna wiadomość zwrócona z backendu lub domyślny komunikat\n* `cause` - oryginalny błąd\n\n              errorMessage = if angular.isString rejection.data\n                rejection.data\n              else if angular.isString rejection.data?.message\n                rejection.data.message\n              else 'Server returned authorization error'\n\n              error = ErrorFactory.create rejection.status,\n               cfg.ERROR_CODE.NO_HTTP_AUTHORIZATION,\n               errorMessage,\n               rejection\n\nNazwa zdarzenia wysyłanego w przypadku błędu konfigurowana jest pod kluczem `HTTP_AUTHORIZATION_ERROR_EVENT`. Domyślnie:\n`rbs-angular-auth-http-error`\n\n              $rootScope.$broadcast cfg.HTTP_AUTHORIZATION_ERROR_EVENT, error\n              error\n            else rejection\n            $q.reject error\n\n        new SecurityErrorInterceptor()\n    ]\n","# `SecurityCtrl`\n\nKontroler bezpieczeństwa\n\n    (angular.module 'rbs-angular-auth').service 'SecurityCtrl', [\n      '$log'\n      '$q'\n      '$rootScope'\n      'Configuration'\n      'ErrorFactory'\n      'JWT'\n      'RuleParser'\n      'TokenManager'\n      ($log, $q, $rootScope, cfg, ErrorFactory, JWT, RuleParser, TokenManager) ->\n\n        class SecurityCtrl\n\n          constructor: () ->\n\nTo pole zawsze zawierać będzie auktualny obiekt `principal`:\n\n            @principal = undefined\n\nPole zawiera zdekodowany `payload` tokena `JWT`:\n\n            @payload = undefined\n\nPonieważ metody `isAuthorized` oraz `isAuthenticated` korzystają z funkcji `_`.`memoize` - czyścimy cache metod w\nmomencie zmiany stanu tokena w `TokenManager`.\n\n            $rootScope.$on cfg.JWT_STORE_EVENT, => @initialize()\n            $rootScope.$on cfg.JWT_CLEAR_EVENT, => @initialize()\n            @initialize()\n\n          clearCaches: ->\n            @isAuthorized.cache.clear?()\n            @$readPrincipal.cache.clear?()\n            @$readPayload.cache.clear?()\n\nPrzy uruchomieniu aplikacji odczytujemy stan:\n\n          initialize: ->\n\n            @clearCaches()\n\n            @payload = @$readPayload()\n\n            onSuccess = (principal) =>\n              @clearCaches()\n              @principal = principal\n\n            onFailure = =>\n              @clearCaches()\n              @principal = undefined\n\n            @getPrincipal().then onSuccess, onFailure\n\nKonwersja pobiera `principal` na podstawie `payload` tokena `JWT` (przeznaczone do rozszerzenia):\n\n          $fetchPrincipal: (payload) -> payload\n\nOdczytanie payloadu `JWT` (synchroniczne):\n\n          $$readPayload: () ->\n            rawToken = TokenManager.getRaw()\n            token = try\n              JWT.parse rawToken\n            catch error\n              $log.error \"Can't parse token:\", rawToken, error\n              TokenManager.clear()\n            if token?\n              {header, payload} = token\n              payload\n\n          $readPayload: _.memoize SecurityCtrl::$$readPayload, -> 'SecurityCtrl-readPayload'\n\nOdczytanie aktualnego `principal` (asynchroniczne):\n\n          $$readPrincipal: () ->\n            payload = @$readPayload()\n            if payload?\n              $q.when @$fetchPrincipal payload\n            else\n              $q.reject()\n\nmetoda korzysta z funkcji `_`.`memoize`\n\n          $readPrincipal: _.memoize SecurityCtrl::$$readPrincipal, -> 'SecurityCtrl-readPrincipal'\n\nPobranie `principal`:\n\n          getPrincipal: () -> @$readPrincipal()\n\nTest czy aktualnie jest zalogowany `principal`:\n\n          isAuthenticated: () ->\n            @payload?\n\nSprawdzenie czy `principal` posiada uprawnienia okreśone regułą `rule`. Metoda korzysta z parametru konfiguracyjnego\n`JWT_PERMISSION_CHECK`:\n\n          $$isAuthorized: (rule, payload) ->\n            unless rule?\n              payload?\n            else if payload? and angular.isFunction cfg.JWT_PERMISSION_CHECK\n              parsed = RuleParser.parse(rule)\n              if parsed.status\n                parsed.value.eval(payload, cfg.JWT_PERMISSION_CHECK) == true\n              else\n                ErrorFactory.throw cfg.ERROR_STATUS.BAD_REQUEST,\n                 cfg.ERROR_CODE.INVALID_AUTHORIZATION_RULE,\n                 \"Can't parse authorization rule: \\\"#{rule}\\\"\"\n            else false\n\n          $isAuthorized: (rule) ->\n            @$$isAuthorized rule, @payload\n\nmetoda korzysta z funkcji `_`.`memoize`\n\n          isAuthorized: _.memoize SecurityCtrl::$isAuthorized, (rule) -> rule or 'SecurityCtrl-isAuthorized'\n\nWylogowanie:\n\n          logout: () ->\n            TokenManager.clear()\n\n        SecurityCtrl\n\n    ]\n","# Konfiguracja modułu `ui-router`\n\n    (angular.module 'rbs-angular-auth-ui-router').config [\n      '$httpProvider'\n      'ConfigurationProvider'\n      ($httpProvider, ConfigurationProvider) ->\n\n## Klucz pod jakim przechowywana jest konfiguracja autoryzacji w danych stanu `ui-router`:\n\n        ConfigurationProvider.put 'DATA_AUTHORIZATION_KEY', 'authorize'\n\n## Nazwa zdarzenia publikowanego, gdy wystąpi błąd autoryzacji przy zmianie stanu:\n\n        ConfigurationProvider.put 'ROUTER_AUTHORIZATION_ERROR_EVENT', 'rbs-angular-auth-ui-router-error'\n\n## Kody błędów:\n\n        ConfigurationProvider.put 'ERROR_CODE',\n          NO_ROUTE_AUTHORIZATION: '0a38f636-c123-4cd5-9249-ad9b6c6724a9'\n\n    ]\n\n    (angular.module 'rbs-angular-auth-ui-router').run [\n      '$log'\n      '$rootScope'\n      'Configuration'\n      'ErrorFactory'\n      'SecurityCtrlInstance'\n      ($log, $rootScope, cfg, ErrorFactory, SecurityCtrlInstance) ->\n\n        $rootScope.$on '$stateChangeStart', (event, toState, toParams, fromState, fromParams) ->\n\n          authorization = toState.data?[cfg.DATA_AUTHORIZATION_KEY]\n\n          if authorization\n\n            error = if authorization is true\n              try\n                unless SecurityCtrlInstance.isAuthenticated()\n                  ErrorFactory.create cfg.ERROR_STATUS.NOT_AUTHORIZED,\n                   cfg.ERROR_CODE.NO_ROUTE_AUTHORIZATION,\n                   \"State \\\"#{toState.name}\\\" is guarded with authorization rule: \\\"#{authorization}\\\", which is not\" +\n                    \" matched\"\n              catch error\n                error\n            else if angular.isString authorization\n              try\n                unless SecurityCtrlInstance.isAuthorized(authorization)\n                  ErrorFactory.create cfg.ERROR_STATUS.NOT_AUTHORIZED,\n                   cfg.ERROR_CODE.NO_ROUTE_AUTHORIZATION,\n                   \"State \\\"#{toState.name}\\\" is guarded with authorization rule: \\\"#{authorization}\\\", which is not\" +\n                    \" matched\"\n              catch error\n                error\n\n            if error?\n              $rootScope.$broadcast cfg.ROUTER_AUTHORIZATION_ERROR_EVENT, toState, toParams, fromState, fromParams, error\n              event.preventDefault()\n\n    ]","# Konfiguracja modułu\n\n    AUTHORIZATION_HEADER = 'Authorization'\n    BEARER_REGEX = /Bearer ([0-9A-Za-z\\.\\-_]+)/\n    BEARER_TEMPLATE = \"\"\"Bearer {{token}}\"\"\"\n\n## Funkcja wstrzykująca token do żądania na podstawie szablonu\n\nFabryka funkcji przyjmuje argumenty:\n1. `header` - nazwa nagłówka w jakim przekazywany jest token - domyślnie `Authorization`\n1. `template` - szablon formatujący nagłówek - może być w formacie:\n  * `function`(`string`): `string` - funkcja formatująca treść nagłówka której argumentem jest token\n  * `string` - szablon `handlebars` - token podstawiony jest pod nazwą zmiennej `token` - domyślnie: `Bearer {{token}}`\n\nZwracana jest funkcja, którą można następnie użyć do konfiguracji parametru `JWT_INJECTOR`.\n\n    TemplateTokenInjector = (header = AUTHORIZATION_HEADER, template = BEARER_TEMPLATE) ->\n      (request, rawToken) ->\n        request.headers[header] = if angular.isString template\n          S(template).template({ token: rawToken, rawToken: rawToken }).s\n        else if angular.isFunction template\n          template rawToken\n        else rawToken\n\n    (angular.module 'rbs-angular-auth').constant 'TemplateTokenInjector', TemplateTokenInjector\n\n## Funkcja wyciągająca token z odpowiedzi za pomocą wyrażenia regularnego\n\nFabryka funkcji przyjmuje argumenty:\n1. `header` - nazwa nagłówka w jakim przekazywany jest token - domyślnie `Authorization`\n1. `template` - szablon nagłówka - może być w formie:\n  * `regex` - wyrażenie regularne które wyciąga token z nagłówka w 1. grupie\n  * `function`(): `string` - funkcja wyciągająca token z nagłówka\n\nZwracana jest funkcja, którą można następnie użyć do konfiguracji parametru `JWT_EXTRACTOR`\n\n    TemplateTokenExtractor = (headerName = AUTHORIZATION_HEADER, template = BEARER_REGEX) ->\n      (response) ->\n        header = response.headers headerName\n        if header?\n          if _.isRegExp template\n            match = template.exec header\n            if angular.isArray match\n              [whole, rawToken] = match\n              rawToken\n          else if angular.isFunction template\n            template header\n          else header\n\n    (angular.module 'rbs-angular-auth').constant 'TemplateTokenExtractor', TemplateTokenExtractor\n\n    (angular.module 'rbs-angular-auth').config [\n      '$httpProvider'\n      'ConfigurationProvider'\n      'TemplateTokenExtractor'\n      'TemplateTokenInjector'\n      ($httpProvider, ConfigurationProvider, TemplateTokenExtractor, TemplateTokenInjector) ->\n\n## Klucz pod jakim przechowywany jest w `$localStorage` token `JWT`:\n\n        ConfigurationProvider.put 'JWT_STORAGE_KEY', 'JWT'\n\n## Klucz pod jakim przechowywany jest w `$rootScope` kontroler `SecurityCtrl`:\n\n        ConfigurationProvider.put 'SECURITY_CONTROLLER_AS', 'security'\n\n## Nazwa zdarzenia publikowanego, gdy ustawiony zostanie nowy token `JWT`:\n\n        ConfigurationProvider.put 'JWT_STORE_EVENT', 'rbs-angular-auth-JWT-store'\n\n## Nazwa zdarzenia publikowanego, gdy usunięty zostanie token `JWT`:\n\n        ConfigurationProvider.put 'JWT_CLEAR_EVENT', 'rbs-angular-auth-JWT-clear'\n\n## Filtr URL dla których aktywowany jest `TokenInterceptor` - regex lub funkcja:\n\n        ConfigurationProvider.put 'HTTP_URL_FILTER', -> true\n\n## Statusy błędów, które są publikowane `$rootScope`:\n\n        ConfigurationProvider.put 'HTTP_AUTHORIZATION_ERROR_STATUS', [401, 403]\n\n## Nazwa zdarzenia publikowanego, gdy wystąpi błąd autoryzacji w `$http`:\n\n        ConfigurationProvider.put 'HTTP_AUTHORIZATION_ERROR_EVENT', 'rbs-angular-auth-http-error'\n\n## Funkcja sprawdzająca obecność uprawnienia `permission` w obiekcie `payload`\n\nFunkcja przyjmuje argumenty:\n\n* payload - payload tokenu `JWT`\n* permission - uprawnienie\n\ni zwraca `boolean`\n\n        ConfigurationProvider.put 'JWT_PERMISSION_CHECK', _.constant false\n\n## Funkcja wstrzykująca token `JWT` do żądania:\n\n        ConfigurationProvider.put 'JWT_INJECTOR', TemplateTokenInjector()\n\n## Funkcja wyciągająca token `JWT` z odpowiedzi:\n\n        ConfigurationProvider.put 'JWT_EXTRACTOR', TemplateTokenExtractor()\n\n## Statusy błędów:\n\n        ConfigurationProvider.put 'ERROR_STATUS',\n          BAD_REQUEST: 400\n          NOT_AUTHORIZED: 401\n          FORBIDDEN: 403\n\n## Kody błędów:\n\n        ConfigurationProvider.put 'ERROR_CODE',\n          INVALID_TOKEN_SIGNATURE: '3b2600fb-8d22-497c-a49b-3dab0b501f04'\n          INVALID_AUTHORIZATION_RULE: '6af67e3a-23bc-4e5d-a46b-839e1ad7425f'\n          NO_HTTP_AUTHORIZATION: 'c472ad9e-d303-4880-aa92-f788c2b0030e'\n\n## Parametr żądania pod którym można przekazać token `JWT`:\n\n        ConfigurationProvider.put 'JWT_REQUEST_PARAM', 'access_token'\n\n## `SecurityErrorInterceptor` publikuje zdarzenia związane z błędami autoryzacji w `$rootScope`:\n\n        $httpProvider.interceptors.push 'SecurityErrorInterceptor'\n\n## `TokenInterceptor` dopisuje token JWT do żądania oraz odczytuje go z odpowiedzi:\n\n        $httpProvider.interceptors.push 'TokenInterceptor'\n\n    ]\n\nPo uruchomieniu modułu publikujemy `SecurityCtrl` w `$rootScope`\n\n    (angular.module 'rbs-angular-auth').factory 'SecurityCtrlInstance', [\n      '$log'\n      'SecurityCtrl'\n      ($log, SecurityCtrl) -> new SecurityCtrl()\n    ]\n\n    (angular.module 'rbs-angular-auth').run [\n      '$log'\n      '$rootScope'\n      'Configuration'\n      'SecurityCtrlInstance'\n      ($log, $rootScope, cfg, SecurityCtrlInstance) ->\n\n        $rootScope[cfg.SECURITY_CONTROLLER_AS] = SecurityCtrlInstance\n    ]\n"]}